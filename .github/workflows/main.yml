name: Create full Release

on:
  push:
    branches:
      - main

jobs:
  calculate_new_tag:
    runs-on: ubuntu-latest
    outputs:
      #tag: ${{ steps.set_tag.outputs.NEW_TAG }}
      tag: 1.3.10
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Ensure all tags are fetched

      - name: Calculate new tag
        id: set_tag
        run: |
          LAST_TAG=$(git describe --abbrev=0 --tags)
          MAJOR=$(echo $LAST_TAG | awk -F'.' '{print $1}')
          MINOR=$(echo $LAST_TAG | awk -F'.' '{print $2}')
          PATCH=$(echo $LAST_TAG | awk -F'.' '{print $3}' | awk -F'-' '{print $1}')
          SUFFIX=$(echo $LAST_TAG | awk -F'-' '{print $2}')
          NEXT_PATCH=$((PATCH + 1))
          NEW_TAG="$MAJOR.$MINOR.$NEXT_PATCH-$SUFFIX"
          echo "new tag is: $NEW_TAG"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_OUTPUT

  get_all_microservices_tags:
    needs: calculate_new_tag
    runs-on: ubuntu-latest
    steps:
      - name: Get all microservices tags
        env:
          ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          #!/bin/bash
          set -x
          # Clear the file first
          rm .env || true
          
          # Start with the new release tag (only once)
          echo "GETAPP_RELEASE_TAG=${{ needs.calculate_new_tag.outputs.tag }}" > .env
          
          # Define repositories in the order you want them to appear
          declare -A REPOSITORIES=(
            ["API"]="getappsh/api"
            ["DELIVERY"]="getappsh/delivery"
            ["DEPLOY"]="getappsh/deploy"
            ["DISCOVERY"]="getappsh/discovery"
            ["OFFERING"]="getappsh/offering"
            ["PROJECT_MANAGEMENT"]="getappsh/project-management"
            ["UPLOAD"]="getappsh/upload"
            ["GETMAP"]="getappsh/getmap"
            ["DASHBOARD"]="getappsh/dashboard"
          )
          
          # Process each repository and append to .env
          for PROJECT in "${!REPOSITORIES[@]}"; do
            REPO=${REPOSITORIES[$PROJECT]}
            TAG=$(curl -s -H "Authorization: token $ACCESS_TOKEN" \
              "https://api.github.com/repos/${REPO}/tags" | \
              jq -r '[.[] | select(.name | contains("develop"))][0].name // "null"')
            
            # Only append if we got a tag
            if [ ! -z "$TAG" ]; then
              echo "${PROJECT}_TAG=${TAG}" >> .env
            else
              echo "Warning: No tag found for ${REPO}"
            fi
          done
          # docs
          DOCS_TAG=$(curl -s https://api.github.com/repos/getappsh/docs/releases/latest | jq -r '.tag_name')
          echo "the docs tag is $DOCS_TAG"
          echo DOCS_TAG=${DOCS_TAG} >> .env

          # Print the final contents without line numbers
          echo "Final .env contents:"
          cat .env
          cp .env env-file

      - uses: actions/upload-artifact@v3
        with:
          name: env-file
          path: env-file

    
        
  create_files_with_updated_env:
    needs:
      - get_all_microservices_tags
      - calculate_new_tag
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main        
          fetch-depth: 0 # Important for getting all tags and history
  
      - name: Download .env file
        uses: actions/download-artifact@v3
        with:
          name: env-file
        
      - name: Move .env file to source directory
        run: |
          mv env-file $GITHUB_WORKSPACE/.env


      - name: Create release files
        env:
          THIS_REPO: ${{ github.repository }}
          RELEASE_TAG: ${{ needs.calculate_new_tag.outputs.tag }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          #!/bin/bash
          set -x
          pwd
          source $GITHUB_WORKSPACE/.env
          eval "echo \"$(cat $GITHUB_WORKSPACE/stuff/getapp-release-info-template.txt)\"" > $GITHUB_WORKSPACE/stuff/getapp-release-info.txt
          eval "echo \"$(cat $GITHUB_WORKSPACE/stuff/images-list-template.txt)\"" > $GITHUB_WORKSPACE/getapp-images-list.txt
          echo "$(cat $GITHUB_WORKSPACE/stuff/docker-compose-template.txt)" > $GITHUB_WORKSPACE/docker-compose/docker-compose.yaml

          cp $GITHUB_WORKSPACE/.env $GITHUB_WORKSPACE/docker-compose/.env
          # test the results
          echo "getapp-images-list NEW file:"
          cat getapp-images-list.txt
          echo "getapp-release-info.txt NEW file:"
          cat stuff/getapp-release-info.txt

          cat stuff/getapp-release-info.txt > readme.md

          chmod +x test-existens-in-harbor.sh
          ./test-existens-in-harbor.sh

          # chart change
          sed -E -i "s,api1":" .*,api":" ${API_TAG},g" integration-chart/values.yml
          sed -E -i "s,delivery":" .*,delivery":" ${DELIVERY_TAG},g" integration-chart/values.yml
          sed -E -i "s,deploy":" .*,deploy":" ${DEPLOY_TAG},g" integration-chart/values.yml
          sed -E -i "s,discovery":" .*,discovery":" ${DISCOVERY_TAG},g" integration-chart/values.yml
          sed -E -i "s,offering":" .*,offering":" ${OFFERING_TAG},g" integration-chart/values.yml
          sed -E -i "s,projectmanagment":" .*,projectmanagment":" ${PROJECT_MANAGEMENT_TAG},g" integration-chart/values.yml
          sed -E -i "s,upload":" .*,upload":" ${UPLOAD_TAG},g" integration-chart/values.yml
          sed -E -i "s,dashboard":" .*,dashboard":" ${DASHBOARD_TAG},g" integration-chart/values.yml
          sed -E -i "s,getmap":" .*,getmap":" ${GETMAP_TAG},g" integration-chart/values.yml
          sed -E -i "s,docs":" .*,docs":" ${DOCS_TAG},g" integration-chart/values.yml
          sed -E -i "s,gitlabrelease":" .*,gitlabrelease":" ${GETAPP_RELEASE_TAG},g" integration-chart/values.yml

          # getapp and getmap ##
          sed -E -i "s,configmap":" .*,configmap":" ${NAMESPACE},g" integration-chart/values.yml
          sed -E -i "s,routePrefix":" .*,routePrefix":" ${NAMESPACE},g" integration-chart/values.yml
          sed -E -i "s,dbName":" .*,dbName":" ${NAMESPACE},g" integration-chart/values.yml
          sed -E -i "s,openshiftProjectName":" .*,openshiftProjectName":" ${NAMESPACE},g" integration-chart/values.yml
          sed -E -i "s,replicaCount":" .*,replicaCount":" ${replicaCount},g" integration-chart/values.yml
          cat integration-chart/values.yml

          # git push
          git config user.email "david@linnovate.net"
          git config user.name "ci-bot"
          echo test >> stuff/nothing
          rm -f GetAppAgent* || true
          rm agent.exe || true

          # chmod +x ./stuff/pull-github-artifacts.sh
          # ./stuff/pull-github-artifacts.sh          # chmod +x ./stuff/pull-github-artifacts.sh


          git add .
          git tag $RELEASE_TAG || true
          git commit -m "Automated commit from GitHub Actions"
          git push origin main --tags

        shell: bash

      - name: Zip all repository files
        env:
          RELEASE_TAG: ${{ needs.calculate_new_tag.outputs.tag }}

        run: |
          zip -r getapp-chart-$RELEASE_TAG.zip . -x "*.git*"
        shell: bash

      - name: Upload zipped files
        uses: actions/upload-artifact@v3
        with:
          name: getapp-chart
          path: getapp-chart-${{ needs.calculate_new_tag.outputs.tag }}.zip

  
  zip_images:
    needs:
      - get_all_microservices_tags
      - calculate_new_tag
      - create_files_with_updated_env
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # - name: zip images
      #   env:
      #     RELEASE_TAG: ${{ needs.calculate_new_tag.outputs.tag }}

      #   run: |
      #     chmod +x getapp-images-to-tar.sh
      #     ./getapp-images-to-tar.sh
      #     mv *.zip getapp-images-$RELEASE_TAG.zip

      # - name: Upload zipped files
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: getapp-images
      #     path: getapp-images-${{ needs.calculate_new_tag.outputs.tag }}.zip

  zip_images_and_chart:
    needs:
      - calculate_new_tag
      - create_files_with_updated_env
      # - zip_images
    runs-on: ubuntu-latest

    steps:
      # - name: Download getapp-images
      #   uses: actions/download-artifact@v3
      #   with:
      #     name: getapp-images

      - name: Download getapp-chart
        uses: actions/download-artifact@v3
        with:
          name: getapp-chart

      - name: zip chart and images to one file
        env:
          RELEASE_TAG: ${{ needs.calculate_new_tag.outputs.tag }}

        run: |
          pwd
          ls -la
          # zip getapp-full-release-$RELEASE_TAG.zip $GITHUB_WORKSPACE/getapp-images-$RELEASE_TAG.zip $GITHUB_WORKSPACE/getapp-chart-$RELEASE_TAG.zip
          zip getapp-full-release-$RELEASE_TAG.zip getapp-chart-$RELEASE_TAG.zip

      - name: Upload zipped files
        uses: actions/upload-artifact@v3
        with:
          name: getapp-images-and-chart
          path: getapp-full-release-${{ needs.calculate_new_tag.outputs.tag }}.zip
        
            
  upload_to_azure:
    runs-on: ubuntu-latest
    needs: 
      - create_files_with_updated_env
      - zip_images_and_chart
      - calculate_new_tag
    steps:
      - name: Download zipped files
        uses: actions/download-artifact@v3
        with:
          name: getapp-images-and-chart
  
      - name: Upload file to Azure Storage
        uses: azure/CLI@v1
        env:
          #AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
          AZURE_STORAGE_KEY: 2R7B3iZ+NyFOZum+M7Co42jvxGhhGKTVSs276w+605gzSOcdc4jrifQjUtvqLGa/HSXnNhbqm+rS+AStq/q8Iw==
          RELEASE_TAG: ${{ needs.calculate_new_tag.outputs.tag }}
          # AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          # AZURE_CONTAINER: ${{ secrets.AZURE_CONTAINER }}
          AZURE_STORAGE_ACCOUNT: getapprelease
          AZURE_CONTAINER: getapp

        with:
          inlineScript: |
            az storage blob upload \
              --account-name $AZURE_STORAGE_ACCOUNT \
              --account-key $AZURE_STORAGE_KEY \
              --container-name $AZURE_CONTAINER \
              --file zip getapp-full-release-$RELEASE_TAG.zip \
              --name zip getapp-full-release-$RELEASE_TAG.zip --overwrite

            # az storage blob upload \
            #   --account-name $AZURE_STORAGE_ACCOUNT \
            #   --account-key $AZURE_STORAGE_KEY \
            #   --container-name $AZURE_CONTAINER \
            #   --file getapp-images-$RELEASE_TAG.zip \
            #   --name getapp-images-$RELEASE_TAG.zip


      - name: Generate Download Link
        id: get-link
        env:
          RELEASE_TAG: ${{ needs.calculate_new_tag.outputs.tag }}
          AZURE_STORAGE_ACCOUNT: getapprelease
          AZURE_CONTAINER: getapp
        run: |
          echo "# Downloads links for GetApp system" > README.md
          echo "" >> README.md
          echo "## Available Versions" >> README.md
          echo "" >> README.md
          echo "### Code files - Helm & Docker-compose" >> README.md
          echo "* [Helm & Docker-compose](https://$AZURE_STORAGE_ACCOUNT.blob.core.windows.net/$AZURE_CONTAINER/zip getapp-full-release-$RELEASE_TAG.zip)" >> README.md
          echo "" >> README.md
          echo "### Docker images" >> README.md
          echo "* [Docker images](https://$AZURE_STORAGE_ACCOUNT.blob.core.windows.net/$AZURE_CONTAINER/zip getapp-full-release-$RELEASE_TAG.zip)" >> README.md
          echo ""
          cat README.md

      - name: Upload README.md file
        uses: actions/upload-artifact@v3
        with:
          name: release-note
          path: README.md



  release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    needs: 
      - upload_to_azure
      - calculate_new_tag
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Important for getting all tags and history

      # - name: Get tag name
      #   id: get_tag
      #   run: |
      #     TAG_NAME=1111
      #     echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT

      # - name: Generate changelog
      #   id: changelog
      #   run: |
      #     # Get commits since last tag
      #     PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${{ steps.get_tag.outputs.TAG_NAME }}^ 2>/dev/null || echo "")
      #     if [ -z "$PREVIOUS_TAG" ]; then
      #       # If no previous tag exists, get all commits
      #       CHANGELOG=$(git log --pretty=format:"* %s" ${{ steps.get_tag.outputs.TAG_NAME }})
      #     else
      #       # Get commits between tags
      #       CHANGELOG=$(git log --pretty=format:"* %s" $PREVIOUS_TAG..${{ steps.get_tag.outputs.TAG_NAME }})
      #     fi
      #     # Escape newlines for GitHub Actions
      #     CHANGELOG="${CHANGELOG//'%'/'%25'}"
      #     CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
      #     CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
      #     echo "CHANGELOG=$CHANGELOG" >> $GITHUB_OUTPUT

      - name: Read Release Notes
        id: read_release_notes
        run: echo "body=$(cat README.md)" >> $GITHUB_ENV

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.calculate_new_tag.outputs.tag }}
          release_name: Release ${{ needs.calculate_new_tag.outputs.tag }}
          body: ${{ env.body }}
          draft: false
          prerelease: false

      # - name: Create Release
      #   uses: actions/create-release@v1
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     tag_name: ${{ needs.calculate_new_tag.outputs.tag }}
      #     release_name: Release ${{ needs.calculate_new_tag.outputs.tag }}
      #     body: |
      #       $(cat README.md)

      #     # body: |
      #     #   ## What's Changed
      #     #  # ${{ steps.changelog.outputs.CHANGELOG }}
      #     draft: false
      #     prerelease: false